# Note

## Chapter 03

- void threeline(void);
- 这种写法只能叫函数声明而不能叫函数定义，只有带函数体的声明才叫定义。上一章讲过，只有分配存储空间的变量声明才叫变量定义，其实函数也是一样，编译器只有见到函数定义才会生成指令，而指令在程序运行时当然也要占存储空间。那么没有函数体的函数声明有什么用呢？它为编译器提供了有用的信息，编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，这样碰到函数调用时才知道怎么生成相应的指令，所以函数原型必须出现在函数调用之前，这也是遵循“先声明后使用”的原则。

## Chapter 08

- gcc -E main.c/ cpp main.c 预处理，替换宏定义，展示头文件的
- printf 会从数组 str 的开头一直打印到 Null 字符为止，Null 字符本身是 Non-printable 字符，不打印。这其实是一个危险的信号：如果数组 str 中没有 Null 字符，那么 printf 函数就会访问数组越界，后果可能会很诡异：有时候打印出乱码，有时候看起来没错误，有时候引起程序崩溃。
- 由于 UNIX 系统标准的字符终端是 24 行 80 列的，接近或大于 80 个字符的较长语句要折行写，折行后用空格和上面的表达式或参数对齐
- indent -kr -i2

## Chapter20

- 用 gcc -c main.c -I stack 编译。用-I 选项告诉 gcc 头文件要到子目录 stack 里找。
- 重复包含头文件有以下问题：
  - 一是使预处理的速度变慢了，要处理很多本来不需要处理的头文件。
  - 二是如果有 foo.h 包含 bar.h，bar.h 又包含 foo.h 的情况，预处理器就陷入死循环了（其实编译器都会规定一个包含层数的上限）。
  - 三是头文件里有些代码不允许重复出现，虽然变量和函数允许多次声明（只要不是多次定义就行），但头文件里有些代码是不允许多次出现的，比如 typedef 类型定义和结构体 Tag 定义等，在一个程序文件中只允许出现一次。
- 同样道理，头文件中的变量和函数声明一定不能是定义。如果头文件中出现变量或函数定义，这个头文件又被多个.c 文件包含，那么这些.c 文件就不能链接在一起了。（还是有点不明白？）
- 陌生指令
  - readelf
  - ldd

## Chapter21

- 预处理的步骤
- \_\_FILE\_\_展开为当前源文件的文件名，是一个字符串，\_\_LINE\_\_展开为当前代码行的行号，是一个整数,\_\_func\_\_当

## Chapter22 Makefile 基础

- 主要用于搭建自动构建程序，自动去匹配生成、更新依赖项
